#!/bin/python
import os, sys
import requests, json, argparse
import hashlib, hmac
import time
import platform
from contextlib import contextmanager
import asyncio
from websockets.asyncio.client import connect
import ssl

APP_ID		= "freeboxvm"
APP_NAME	= "Freebox VM manager"
APP_VERSION	= "0.0.1"
DEVICE_NAME	= platform.node()

API_URL		= f"http://mafreebox.freebox.fr/api/v8"

TOKEN_FILE = "freeboxvm_token.json"

def load_app_token():
    """Load persisted Freebox application token and track_id from disk.

    Returns
    -------
    tuple[str|None, str|None]
        (app_token, track_id) if present; (None, None) otherwise.
    """
    if os.path.exists(TOKEN_FILE):
        with open(TOKEN_FILE, "r") as file:
            data = json.load(file)
            return data["app_token"], data["track_id"]
    return None, None

def save_app_token(app_token, track_id):
    """Persist Freebox application token and track_id to disk.

    Parameters
    ----------
    app_token : str
        Token issued by the Freebox authorization step.
    track_id : str
        Tracking identifier returned by the authorization API.
    """
    with open(TOKEN_FILE, "w") as file:
        json.dump({"app_token": app_token, "track_id": track_id}, file)

def api_request(method, endpoint, session_token=None, **kwargs):
    """Call a Freebox OS API endpoint and return its `result` payload.

    Parameters
    ----------
    method : str
        HTTP verb, e.g. 'get', 'post'.
    endpoint : str
        API path beginning with '/'.
    session_token : str | None
        Optional session token to send as 'X-Fbx-App-Auth'.
    **kwargs : dict
        Extra arguments forwarded to `requests.request` (json=data, params, etc.).

    Returns
    -------
    Any | str | None
        The `result` field on success; the string 'forbidden' on HTTP 403;
        or None on network/JSON errors.

    Side Effects
    ------------
    Logs API/network/JSON errors to journald.
    """
    headers = {}
    if session_token:
        headers["X-Fbx-App-Auth"] = session_token

    try:
        response = requests.request(method, f"{API_URL}{endpoint}", headers=headers,
                                    timeout=5, **kwargs)
        response.raise_for_status()
        data = response.json()
        if data.get('success'):
            return data.get('result')
        else:
            print(f"Erreur d'API sur {endpoint}: {data.get('msg')}")
    except requests.exceptions.HTTPError as e:
        if e.response.status_code == 403:
            return "forbidden" # Return a special string for 403 errors
        else:
            print(f"Erreur HTTP sur {endpoint}: {e}")
    except requests.exceptions.RequestException as e:
        print(f"Erreur de réseau sur {endpoint}: {e}")
    except json.JSONDecodeError:
        print(f"Erreur de décodage JSON sur {endpoint}")
    return None

def freebox_connect():
    """Establish a Freebox OS API session token.

    1) Load stored app token/track_id; otherwise request authorization and poll
       until the user approves the app on the Freebox.
    2) Compute HMAC-SHA1 password from challenge and app_token.
    3) Open a login session and return the session token.

    Returns
    -------
    str | None
        A valid session token, or None if the flow fails.

    Side Effects
    ------------
    May persist the app token to disk. Logs status messages to journald.
    """
    # Charger le token depuis le fichier ou obtenir une nouvelle autorisation
    app_token, track_id = load_app_token()
    if not app_token or not track_id:
        auth_data = api_request("post", "/login/authorize/", json={
            "app_id": APP_ID, "app_name": APP_NAME,
            "app_version": APP_VERSION, "device_name": DEVICE_NAME
        })
        if not auth_data: return None
        track_id, app_token = auth_data['track_id'], auth_data['app_token']
        save_app_token(app_token, track_id)
        print("Veuillez accepter l'application sur la Freebox")
        max_retries = 24
        for i in range(max_retries):
            status_data = api_request("get", f"/login/authorize/{track_id}")
            status = status_data.get('status') if status_data else None
            if status == 'granted':
                print("Autorisation approuvée.")
                break
            elif status == 'pending':
                print("En attente d'autorisation...")
                time.sleep(5)
            else:
                print(f"Echec d'autorisation avec le status: {status}")
                return None
        else:
            print("Epuisement du délai d'attente d'autorisation après 2 minutes.")
            return None

    challenge_data = api_request("get", f"/login/authorize/{track_id}")
    if not challenge_data or not isinstance(challenge_data, dict):
        print("Echec pour gagner le challenge, le token doit être invalide.")
        return None
    challenge = challenge_data['challenge']
    password = hmac.new(app_token.encode(), challenge.encode(), hashlib.sha1).hexdigest()

    login_data = api_request("post", "/login/session/", json={"app_id": APP_ID, "password": password})
    if login_data == "forbidden":
        print(f"Fichier token invalide {TOKEN_FILE}")
        return None
    return login_data['session_token'] if login_data else None

async def console_link(session_token, vm_id):
    url = f"wss://mafreebox.freebox.fr/api/v8/vm/{vm_id}/console"

    # TLS verification
    ssl_ctx = ssl.create_default_context()
    ssl_ctx.check_hostname = False
    ssl_ctx.verify_mode = ssl.CERT_NONE
    async with connect(
        url,
        additional_headers={"X-Fbx-App-Auth": session_token},
        subprotocols=['binary'],
        ssl=ssl_ctx
    ) as ws:
        loop = asyncio.get_running_loop()

        CTRL_A = b"\x01"              # Ctrl-A
        DETACH_KEYS = { b"d", b"D" } # Ctrl-A D
        PASSTHRU_KEYS = { b"a", b"A" } # Ctrl-A A

        async def rx():
            async for msg in ws:
                if isinstance(msg, str):
                    sys.stdout.write(msg)
                else:
                    sys.stdout.buffer.write(msg)
                sys.stdout.flush()

        async def tx():
            waiting_cmd = False
            while True:
                data = await loop.run_in_executor(None, sys.stdin.buffer.read, 1)
                if not data:
                    break
                if waiting_cmd:
                    waiting_cmd = False
                    if data in DETACH_KEYS:
                        await ws.close()
                        return
                    elif data in PASSTHRU_KEYS:
                        await ws.send(CTRL_A)
                    else:
                        await ws.send(CTRL_A + data)
                    continue

                if data == CTRL_A:
                    waiting_cmd = True
                else:
                    await ws.send(data)

        await asyncio.gather(rx(), tx())

@contextmanager
def raw_terminal():
    import termios, tty

    fd = sys.stdin.fileno()
    old = termios.tcgetattr(fd)
    try:
        tty.setraw(fd)
        yield
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old)

def system_info(session_token):
    info = api_request("get", "/vm/info/", session_token)
    print(f"Mémoire Totale: {info['total_memory']}\tMémoire Utilisée: {info['used_memory']}")
    print(f"Nombre de CPUs: {info['total_cpus']}\tCPUs Utilisés: {info['used_cpus']}")
    print(f"USB externe alloué: {'Oui' if info['usb_used'] else 'Non'}")
    print("Liste des ports USB disponibles:")
    for usb in info['usb_ports']:
        print(f"   {usb}")

def get_vm_list(session_token):
    vm_list = api_request("get", "/vm/", session_token)
    return vm_list

def list(session_token):
    vm_list = get_vm_list(session_token)
    if not vm_list:
        print("Pas de VM disponible", file=sys.stderr)

    print("ID\tSTATUS\tNAME")
    for vm in vm_list:
        print(f"{vm['id']}\t{vm.get('status')}\t{vm.get('name')}")

def select_vm(session_token, selector: str | None):
    vm_list = get_vm_list(session_token)
    if not vm_list:
        return None

    if selector is None:
        return next((vm for vm in vm_list if vm["status"] == "running"), vm_list[0])

    try:
        wanted_id = int(selector)
        match = next((vm for vm in vm_list if int(vm["id"]) == wanted_id), None)
        if match:
            return match
    except ValueError:
        pass

    matches = [ vm for vm in vm_list if selector == vm["name"]]
    if len(matches) == 1:
        return matches[0]

    if len(matches) > 1:
        print("Multiple matches:", file=sys.stderr)
        for vm in matches:
            print(f"  {vm['id']}: {vm['name']} {vm.get('status')}", file=sys.stderr)
        return None

    return None

def console(session_token, args):

    vm = select_vm(session_token, args.vm)
    if not vm:
        print("VM non trouvé. Utilisez 'freeboxvm list' pour voir la liste.", file=sys.stderr)
        sys.exit(1)

    vm_id, vm_name = vm["id"], vm["name"]

    print(f"Connexion à la console de '{vm_name}' (VM #{vm_id}), Ctrl-A D pour sortir...",
          file=sys.stderr)

    with raw_terminal():
        try:
            asyncio.run(console_link(session_token, vm_id))
        except KeyboardInterrupt:
            pass

def poweron(session_token, args):

    vm = select_vm(session_token, args.vm)
    if not vm:
        print("VM non trouvé. Utilisez 'freeboxvm list' pour voir la liste.", file=sys.stderr)
        sys.exit(1)

    vm_id, vm_name = vm["id"], vm["name"]

    print(f"Démarrage de '{vm_name}' (VM #{vm_id})",
          file=sys.stderr)

    api_request("post", f"/vm/{vm_id}/start", session_token)

def poweroff(session_token, args):
    vm = select_vm(session_token, args.vm)
    if not vm:
        print("VM non trouvé. Utilisez 'freeboxvm list' pour voir la liste.", file=sys.stderr)
        sys.exit(1)

    vm_id, vm_name = vm["id"], vm["name"]

    print(f"Extinction de '{vm_name}' (VM #{vm_id})",
          file=sys.stderr)

    if args.force:
        api_request("post", f"/vm/{vm_id}/stop", session_token)
    else:
        api_request("post", f"/vm/{vm_id}/powerbutton", session_token)

def reset(session_token, args):

    vm = select_vm(session_token, args.vm)
    if not vm:
        print("VM non trouvé. Utilisez 'freeboxvm list' pour voir la liste.", file=sys.stderr)
        sys.exit(1)

    vm_id, vm_name = vm["id"], vm["name"]

    print(f"Redémmarage de '{vm_name}' (VM #{vm_id})",
          file=sys.stderr)

    api_request("post", f"/vm/{vm_id}/restart", session_token)

def parse_args():
    p = argparse.ArgumentParser(prog="freeboxvm", description="Freebox VM manager")

    sub = p.add_subparsers(dest="cmd", required=True)
    sp_system = sub.add_parser("system", help="Display Freebox system info")
    sp_list = sub.add_parser("list", help="List VMs")
    sp_console = sub.add_parser("console", help="Open VM console")
    sp_console.add_argument("vm", nargs="?", help="VM id or name; default = first running")
    sp_poweron = sub.add_parser("poweron", help="Power on a VM")
    sp_poweron.add_argument("vm", nargs="?", help="VM id or name; default = first running")
    sp_poweroff = sub.add_parser("poweroff", help="Power off a VM")
    po_force = sp_poweroff.add_argument("--force", "-f", action='store_true', help="Force power off a VM")
    sp_poweroff.add_argument("vm", nargs="?", help="VM id or name; default = first running")
    sp_reset = sub.add_parser("reset", help="Reset on a VM")
    sp_reset.add_argument("vm", nargs="?", help="VM id or name; default = first running")

    return p.parse_args()

def main():

    args = parse_args()

    session_token = freebox_connect()
    if not session_token:
        print("Freebox inaccessible.")
        return

    if (args.cmd == "system"):
        system_info(session_token)

    if args.cmd == "list":
        list(session_token)

    if args.cmd == "console":
        console(session_token, args)

    if args.cmd == "poweron":
        poweron(session_token, args)

    if (args.cmd == "poweroff"):
        poweroff(session_token, args)

    if (args.cmd == "reset"):
        reset(session_token, args)


if __name__ == "__main__":
    main()
